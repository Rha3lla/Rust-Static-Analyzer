# Safety Comment Association Policy

This document defines how the Rust Static Analyzer associates
**safety justification comments** with `unsafe` constructs.

This policy applies to all rules that require explicit documentation
of unsafe behavior, including but not limited to:
- HA-RUST-0001 — Unjustified `unsafe` block
- HA-RUST-0003 — Missing `SAFETY:` comment in unsafe block
- HA-RUST-0025 — Public unsafe API missing documentation

The intent is to ensure **predictable, auditable, and enforceable**
documentation of unsafe invariants in high-assurance Rust codebases.

---

## 1. Definitions

### Unsafe Construct
Any of the following Rust constructs:
- `unsafe { ... }`
- `unsafe fn`
- `unsafe impl`
- `unsafe trait`

### Safety Justification
A comment containing the **case-sensitive token**:


## SAFETY


followed by a non-empty explanation of the safety invariants relied upon.

### Associated
A safety justification is considered *associated* with an unsafe construct
if it satisfies the adjacency and content rules defined in this document.

---

## 2. Primary Association Rules

A `SAFETY:` comment is associated with an unsafe construct if **any one**
of the following conditions is met.

### 2.1 Immediate Preceding Comment Block

The `SAFETY:` comment appears in a contiguous comment block that:
- directly precedes the unsafe construct
- contains no intervening non-comment, non-attribute tokens
- is separated only by whitespace

No blank line is permitted between the comment block and the unsafe construct
by default.

#### Example (valid)

```rust
// SAFETY:
// - `ptr` is non-null
// - `ptr` points to `len` valid elements
unsafe {
    core::ptr::copy_nonoverlapping(src, dst, len);
}


## 2.2 Same-Line Trailing Comment

The SAFETY: comment appears on the same line as the unsafe construct.

unsafe { *ptr = value; } // SAFETY: `ptr` is valid and properly aligned

This form is permitted but discouraged for complex invariants


## 2.3 Attribute Sandwich Association

Rust attributes frequently appear between comments and code.
Association is permitted if:

the SAFETY: comment immediately precedes a block of attributes

the attributes immediately precede the unsafe construct

only whitelisted attributes appear between the comment and unsafe

Whitelisted Attributes

By default, the following are allowed:

#[cfg(...)]

#[cfg_attr(...)]

#[allow(...)], #[deny(...)]

#[inline], #[cold], #[must_use]

The maximum number of attribute lines allowed is configurable
(default: 8).

Example (valid)
// SAFETY: This block is only compiled when the MMIO region is valid.
#[cfg(target_arch = "arm")]
unsafe {
    mmio_write(REG, value);
}


## Disallowed Associations

A safety justification is not associated if any of the following occur:

3.1 Intervening Code

Any non-comment, non-attribute token between the SAFETY: comment
and the unsafe construct breaks association.
// SAFETY: ...
let x = 1;
unsafe { ... } // ❌ not associated


## 3.2 Ambiguous Binding

A single SAFETY: comment may only bind to one unsafe construct.

If multiple unsafe constructs follow, the justification binds only to the
nearest valid one.

### 4. Nested Unsafe Constructs
## 4.1 Default Behavior

Each unsafe construct requires its own safety justification.

Outer justifications do not implicitly cover nested unsafe blocks.

This is the default behavior for:

  high_assurance

  misra_rust profiles


## 4.2 Optional Relaxation (Configurable)

Projects may optionally allow inner unsafe blocks to omit a justification
if they are entirely covered by an outer documented invariant.

This behavior must be explicitly enabled and is discouraged in
high-assurance contexts.


### 5. Content Quality Requirements

A SAFETY: comment is considered invalid if:

  it is empty

  it is purely tautological (e.g., “this is safe”)

  it restates the code without describing invariants


## Heuristic Content Checks

At minimum, the justification should:

  describe why the operation is safe

  identify assumptions or guarantees

Heuristics may include:

  presence of terms such as:
  invariant, guarantee, caller, valid, aligned, lifetime,
  non-null, bounds, exclusive, alias
  multi-line explanations or bullet points

Content quality failures should default to Warning, not Error.

### 6. Macros and Generated Code
## 6.1 Unsafe in Macro Expansions

Unsafe constructs originating from macro expansion present limited
source-level context.

Policy:

  If the unsafe span is attributable to a macro invocation:

  attempt association with a preceding SAFETY: comment

  otherwise emit a diagnostic noting macro origin

Enforcement level is profile-dependent

Default:

  high_assurance: require justification when attributable

  embedded: warn only


## 6.2 Generated Files

Files generated during build (e.g., OUT_DIR, target/) are excluded
by default unless explicitly included via configuration.


### 7. Configuration Parameters

The following configuration parameters control this policy:

  safety_comment_token (default: "SAFETY:")

  allow_blank_line_between_comment_and_unsafe (default: false)

  max_attribute_lines_between_comment_and_unsafe (default: 8)

  require_safety_for_nested_unsafe (default: true)

  require_safety_for_macro_unsafe (profile-dependent)

  content_quality_enforcement (off | warn | error, default: warn)


### 8. Diagnostics and Developer Guidance

Diagnostics related to missing or invalid safety justifications must:

  reference the applicable rule ID

  explain the association requirement

  include an example of an acceptable SAFETY: comment

The goal is corrective guidance, not punitive enforcement.


### 9. Evolution of This Policy

This policy may evolve as:

  additional unsafe patterns are identified

  Rust language features change

  project assurance needs grow

Changes must preserve backward traceability and be documented.

